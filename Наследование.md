## Что это?
Создание новой сущности на основе существующей. В программировании - механизм иерархии сущностей и повторного использования кода. При наследованиии новая сущность перенимает отличительные черты сущности-родителя и может добавлять свои.  В программировании этот механизм реализуется через систему [[Класс|классов]]. ^74d0f0

---

## Пример
И собака, и кошка являются животными, имеют по 4 ноги, по два глаза, хвосту и тд. Их иерархия четко прослеживается: Собака - наследник класса Животное-Млекопитающее-Четырехногое, Кошка тоже является наследником этого класса.

---

## Пример кода
Наследование в C++ происходит с помощью синтаксиса:
	`class Имя_класса: модификатор_доступа Родитель`

[[Модификатор доступа]] в данном случае работает немного в другом смысле:
- public - никакие поля при наследовании не изменяют своего уровня доступа. Публичные поля остаются публичными, Защищенные защищенными, а приватные приватными.
- protected - изменяет полученные Публичные поля, делая их Защищенными. Не влияет на Приватные.
- private - все получаемые поля становятся Приватными.

```cpp
#include <iostream>

class Parent
{
private:
	int private_data;
protected:
	int protected_data;
public:
	int public_data;
	Parent() = default;
	void set_data()
	{
		protected_data = 10;
		public_data = 10;
	}
};

// Публичное наследование: наследник не изменяет ничего,
// но приватные поля родителя так и остаются в родителе
class PublicChild: public Parent
{
public:
	PublicChild() = default;	
};

// Защищенное наследование: наследник изменяет все публичные на защищенные,
// что делает публичные поля родителя закрытыми от внешнего влияния,
// но позволяет получать доступ к ним внутри иерархии наследников
class ProtectedChild: protected Parent
{
public:
	ProtectedChild() = default;
};

// Следующее поколение защищенного наследования:
// всё так же может получать доступ к защищенным полям верхнего родителя и
// использовать публичные изнутри.
class ProtectedChildChild: public ProtectedChild
{
public:
	ProtectedChildChild() = default;
	void my_func()
	{
		set_data();
		std::cout << protected_data << public_data << std::endl;
	}
};

// Приватное наследование: жадный тип наследования,
// при котором наследник получает все поля родителя,
// кроме приватных и больше не отдает их никуда:
// ни внешнему пользователю, ни своим наследникам
class PrivateChild: private Parent
{
public:
	PrivateChild() = default;
};

class PrivateChildChild: public PrivateChild
{
public:
	PrivateChildChild() = default;
	void my_func()
	{
		
	}
};

int main()
{
	// Можем получить доступ к полям родителя извне 
	auto public_child = PublicChild();
	std::cout << public_child.public_data << std::endl;
	public_child.set_data();
	
	// Уже не можем так сделать с другими
	auto protected_child = ProtectedChild();
	auto private_child = PrivateChild();
}
```

---

## Несколько замечаний
В последнее время часто возникают дискуссии на тему "Должно ли наследование продолжать быть парадигмой ООП?". Происходит это из-за того, что активное использование данной концепции приводит к не самым хорошим последствиям - ваша иерархия становится слишком сильно [[Связанность|связанной]]. ^e24ac9